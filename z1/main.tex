\documentclass[fleqn]{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{parskip}
\usepackage{icomma}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage{transparent}
\usepackage{listings}



\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\alph{subsection})}
\renewcommand\thesubsubsection{}
\newcommand\square[1]{
	\fcolorbox{black}{#1}{\rule{0pt}{6pt}\rule{6pt}{0pt}}
}

\brokenpenalty=1000
\clubpenalty=1000
\widowpenalty=1000

\title{TM -- Laboratorium 1.}
\author{Krystian Chachuła \\ Dawid Gruszczyński \\ Marcin Skrzypkowski}

\begin{document}

\maketitle

\setcounter{page}{0}
\thispagestyle{empty}

\pagebreak

\setcounter{page}{1}

\section{Wtęp}

Na pierwszym laboratorium mieliśmy za zadanie oswoić się z układem FPGA symulującym mikroprocesor Z80 przez rozpoznanie podstawowych instrukcji wejścia/wyjścia oraz pamięci. Ćwiczenie składało się z trzech punktów: przedstawienia podstawowych instrukcji na oscyloskopie, złożenia układu atywującego sygnał $\overline{WAIT}$ na zadaną ilość taktów po spełnieniu określonych warunków oraz zbudowania układu pułakpującego procesor w tym sygnale do czasu wyzwolenia przełącznikiem bistabilnym.

%TODO: zrobić listę z wymienionych układów
Zaprojektowane przed laboratorium układy zbudowaliśmy z dostępnych układów SML-3: ${10\_PS1}$ (moduł zasilacza), ${100\_LED8}$ (zestaw 8 diod), ${13x\_IN6}$ (zestaw bistabilnych przełączników), ${202\_NAND}$ (zestaw bramek nand), ${380\_NOTx6}$ (moduł sześciu bramek negujących), ${451\_IN\_4xHEX}$ (zestaw przełączników szesnastkowych), ${331\_MUX-Dx2}$ (zestaw multiplekserów oraz przerzutników typu D), ${400\_74194x2}$ (moduł rejestrów przesuwnych) oraz procesora Z80 zrealizowanego na układzie FPGA.
Schematy do zadania drugiego i trzeciego podane są podczas omawiania poszczególnych problemów. Programy pisane w Assembly dla procesora Z80 wgrywaliśmy z pomocą aplikacji NoICE, która umożliwiała sprawdzenie adresów i wielkości poszczególnych instrukcji oraz testowanie ich i uniknięcie nieskończonej pętli podczas testowania programu, od której jedyną ucieczką był reset procesora. Aby jednak uzyskać porządany wyraźny obraz na oscyloskopie, należało przełączyć aplikację w tryb RUN, gdyż w przeciwnym wypadku oscylogram pokazywał również polecenia wysyłane przez sam program NoICE, co uniemożliwiało identyfikację i analizę naszego programu.



\section{Odczytywanie przebiegów instrukcji na oscyloskopie}
Pierwsze zadanie polegało na obserwacji i opisie pięciu przebiegów sygnałów procesora: wczytywanie i zapis do pamięci, wczytywanie i zapis do przestrzeni wejścia/wyjśćia oraz cykl pobierania kodu instrukcji.
W celu realizacji zadania napisaliśmy prosty program w Assembly Z80, który po uruchomieniu w aplikacji NoICE i włączeniu trybu RUN pozwalał na obserwację wyżej wymienionych przebiegów.

\lstinputlisting{src/1.lst}

%TODO: dodać rozmiary instrukcji i argumentów
\subsection{Cykl fetch}

Na początku realizacji każdego polecenia mikroprocesor pobiera kod instrukcji, co jest sygnalizowane stanem niskim na wyjściach $\overline{MREQ}$, $\overline{RD}$ oraz $\overline{M1}$. Zaraz potem następuje odświeżenie pamięci sygnalizowane stanem niskim jedynie na wyjściu $\overline{MREQ}$ (oraz $\overline{RFSH}$, lecz nie widać tego na oscylogramie). W trakcie odświeżania dekodowany jest także kod pobranej instrukcji.
Cały cykl można zaobserwować w bloku \square{red} na poniższym zdjęciu. Nieprzedłużony sygnałem $\overline{WAIT}$ trwa 4 cykle zegarowe.

\subsection{Cykl odczytu z pamięci}

Podczas tego cyklu zaznaczonego w bloku \square{cyan} następuje pobranie argumentów do wykonania polecenia OUT, a więc odczyt z pamięci.
Sygnalizowane jest to niskim stanem na wyjściach $\overline{MREQ}$ i $\overline{RD}$. Jej wykonanie trwa zwykle 3 cykle zegarowe.
%TODO: sprawwdzić jakie to polecenie

\subsection{Cykl zapisu do układów wejścia/wyjścia}

Cykl zapisu do pamięci:
Podczas cyklu zaznaczonego w bloku nr 5 następuje zapis do pamięci realizowany przez isntrukcję LD, sygnalizowane jest to stanem niskim na wyjściach $\overline{MREQ}$ i $\overline{WR}$ ($\overline{WR}$ nie jest widoczne na oscylogramie). Sygnał $\overline{WR}$ pojawia się na wyjściu procesora jeden cykl zegarowy po wystawieniu sygnału $\overline{MREQ}$, by dane na szynie zdążyły się ustabillizować. Cała instrukcja zapisu trwa zwykle 3 cykle zegarowe.



\subsection{Cykl odczytu z przestrzeni wejścia/wyjścia}

%TODO sprawdzić
Podczas cyklu zaznaczonego w bloku \square{violet} następuje odczyt z układów wejścia/wyjścia realizowany przez instrukcję IN, sygnalizowany jest stanem niskim na wyjściach $\overline{IORQ}$ i $\overline{RD}$. Podczas wykonywania instrukcji z przestrzeni wejśćia/wyjścia w każdej instrukcji automatycznie jest wstawiany jeden cykl $\overline{WAIT}$. Jest to spowodowane późnym uaktywnieniem sygnału $\overline{IORQ}$ (jest aktywowany w drugim cyklu zegarowym), co uniemożliwia wystarczająco szybkie dekodowanie instrukcji i uaktywnienie sygnału $\overline{WAIT}$ w tym samym cyklu zegarowym. Z tego powodu ta instrukcja trwa zwykle 4 cykle zegarowe.

\subsection{Cykl zapisu do pamięci}
Podczas cyklu zaznaczonego w bloku \square{green} następuje zapis do pamięci realizowany przez instrukcję LD, sygnalizowane jest to stanem niskim na wyjściach $\overline{MREQ}$ i $\overline{WR}$ ($\overline{WR}$ nie jest widoczne na oscylogramie). Również w tej instrukcji dodawany jest automatycznie sygnał ${WAIT}$, dlatego cykl zapisu w przestrzeni wejscia/wyjścia trwa zwykle 4 cykle zegarowe.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{img/1a.png}
	\caption{}
\end{figure}
\section{Generowanie sygnału opóźniającego}
Naszym zdaniem było wstawianie \textbf{dwóch} taktów opóźnienia po wykryciu \textbf{odczytu danych z przestrzeni wejścia/wyjścia}. Procesor automatycznie wstawia jeden takt opóźnienia przy przy wykonywaniu instrukcji dotyczących tej przestrzeni, zatem łącznie mieliśmy uzyskać trzy takty opóźnienia.

Pierwszą naszą czynnością było stworzenie funkcji logicznej, która przyjmowała wartość $1$, gdy był spełniony warunek z treści zadania lub $0$ w pozostałych przypadkach. Następnie zaprojektowaliśmy układ kombinacyjny realizujący tę funkcję. Początkowo wykorzystaliśmy bramki \textit{NAND} oraz \textit{NOT}, ale ze względu na trudność modyfikacji oraz małą przejrzystość takiego układu finalnie zdecydowaliśmy się na wykorzystanie multipleksera.

% TODO: napisać o module SML-3 z rejestrem
Do odliczania taktów zegara procesora zdecydowaliśmy się użyć rejestru przesuwnego z modułu SML-3 ${400\_74194x2}$. Pozwala on zliczyć maksymalnie 4 takty zegara, więc biorąc pod uwagę wbudowany takt oczekiwania byliśmy w stanie dodać maksymalnie 3 takty. Było to jednak wystarczające do wykonania zadania. Wejściem zegarowym rejestru był zanegowany sygnał zegarowy, ponieważ sygnał $\overline{WAIT}$ był próbkowany przez procesor podczas opadającego zbocza zegara, więc każde przesunięcie zawartości rejestru oznaczało wydłużenie sygnału opóźniającego o jeden takt.  Alternatywą do naszego rozwiązania było użycie licznika, lecz rejestr był rozwiązaniem prostszym.

Ładowanie rejestru oraz przesuwanie odbywało się przez podłączenie do wejścia \textit{S0} sygnału $\overline{IORQ}$: w stanie wysokim następowało ładowanie rejestru, a w stanie niskim przesuwanie.

Ilość wymaganych przez zadanie taktów zegara była ładowana do rejestru z modułu przełączników szesnastkowych IN\_4xHEX. Ilość taktów była równoważna z ilością kolejnych jedynek w rejestrze patrząc od najmniej znaczącego bitu. Umożliwiło to późniejszą trywialną modyfikację zaadania, gdy mieliśmy wprowadzić przykładowo jeden dodatkowy tak oczekiwania. Liczba ładowana z przełączników była już uzupełniona o takt automatyczny, więc gdy ładowaliśmy do rejestru liczbę 3, Oznaczało to wprowadzenie dwóch taktów oczekiwania, z czego jeden był automatyczny. Uzyskiwaliśmy więc przedłużenie o jeden takt zegarowy.

Wyjście multipleksera oraz najmniej znaczący bit rejestru zostały doprowadzone do wejść bramki \textit{NAND}. W ten sposób otrzymaliśmy wymagany sygnał $\overline{WAIT}$.

Podczas testowania złożonego układu korzystaliśmy z programu z punktu 2.  W kolorze \square{blue} widać funkcję $\overline{WAIT}$ generowaną przez nasz układ. Dla położenia 0 i 1 przełącznika szesnastkowego sygnały $\overline{IORQ}$ oraz $\overline{RD}$ nie ulegają wydłużeniu. Powodem jest traktowanie pierwszego taktu oczekiwania jako sygnał domyślny, generowany przez procesor. Dlatego też widoczna na oscylogramach (a) i (b) instrukcja odczytu z przestrzeni wejścia/wyjścia trwa 4 takty zegara. Na wykresach (c), (d) i (e) wyraźnie widać, że została przedłużona kolejno o jeden, dwa oraz trzy takty zegarowe. Poniżej znajduje się schemat funkcji generującej takty oczekiwania oraz przebiegi sygnałów dla ustawień przełącznika szesnastkowego 0, 1, 3, 7, 15 (wykresy kolejno (a), (b), (c), (d) oraz (e)).



\begin{figure}[H]
	\centering


	%	\subfloat[blabla]{\includegraphics[width=2.5in]{img/2a.png}}
	%	\subfloat[blabla]{\includegraphics[width=2.5in]{img/2b.png}}

	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{img/2a.png}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{img/2b.png}
		\caption{}
	\end{subfigure}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{img/2c.png}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{img/2d.png}
		\caption{}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{img/2e.png}
		\caption{}
	\end{subfigure}
	\caption{}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.8\textwidth}
		\includegraphics[width=\textwidth]{img/z2.png}
  \end{subfigure}
	\caption{schemat do punktu 3}
\end{figure}

\section{Wstrzymywanie pracy procesora}
Ostatnim zadaniem była modyfikacja poprzedniego układu w taki sposób, aby zamiast wstawiać takty oczekiwania, generować sygnał $\overline{WAIT}$ do momentu uzyskania zbocza przełącznika.
Zdecydowaliśmy się zastąpić rejestr przerzutnikiem typu D, gdyż element zliczający nie był już potrzebny, a wystarczył prosty układ z pamięcią. Przerzutnik pozwalał nam też na wykrywanie zbocza przełączania przez podłączenie go do wejścia zegarowego.
W normalnych warunkach (gdy procesor nie wpadał w pułapkę) przerzutnik był resetowany sygnałem \textit{M1} (na wyjściu $\overline{Q}$ pojawiał się sygnał $1$). Do wejścia D był podpięty stały sygnał wysoki, dzięki czemu zbocze przełącznika powodowało dezaktywację sygnału $\overline{WAIT}$ poprzez resetowanie wyjścia $\overline{Q}$ przerzutnika. Do wejścia $\overline{SET}$ przerzutnika był na stałe podłączony sygnał $1$, gdyż nie było potrzeby z niego korzystać.

Układ multipleksera pozostawiliśmy bez zmian, natomiast do bramki \textit{NAND}, z której wychodzi sygnał $\overline{WAIT}$, zamiast najmniej znaczącego bitu rejestru podłączyliśmy wyjście $\overline{Q}$ przerzutnika.

Następnie zmodyfikowaliśmy kod z poprzedniego zadania, aby było widać, że procesor jest zatrzymywany po każdym wystąpieniu warunku. Ten się nie zmienił, procesor wciąż miał być pułapkowany odcczytem z przestrzeni wejścia/wyjścia, więc dodaliśmy jedno polecenie IN, abby można było stwierdzić, że pułapkowanie następuje od razu po zwolnieniu z poprzedniego okresu oczekiwania i gdy są spełnione warunki zadania.

Na rysunku $5$ widoczny jest proces wyzwalania procesora ze stanu oczekiwania, wykonianie trzech kolejnych instrukcji i ponowne wejście do stanu oczekiwania po napotkaniu drugiego polecenia IN. Rysunek $6$ pokazuje analogiczną sytuację. Na oscylogramie widać wyzwolenie ze stanu oczekiwania, wykonanie dwóch instrukcji oraz ponowne pułapkowanie po wykryciu polecenia IN.
Wyraźnie widać, że nasz układ powoduje pułapkowanie procesora z każdym wykryciem instrukcji odczytu z przestrzeni wejścia/wyjścia, można również zidentyfikować, które polecenie wprwadziło procesor do tego stanu. Rysunek piąty przedstawia pułapkowanie w linii programu [\textit{IN A, (04h)}], rysunek 6 w linii programu [\textit{IN A, (0h)}].

Schemat połączeń znajduje się poniżej oscylogramów. Nasz program do testowania zadania 3:

\lstinputlisting{src/2.lst}

%TODO: wstawić kod z zadania 3

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{img/3a.png}
	\caption{}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{img/3b.png}
	\caption{}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{img/3c.png}
	\caption{}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/z3.png}
	\caption{}
\end{figure}

\section{Problemy}

Podczas prób budowy zaprojektowanych układów natrafiliśmy na kilka problemów, które ostatecznie udało nam się rozwiązać.
Jednym z nich były szybko zanikające sygnały. Było to spowodowane podłączeniem dwóch modułów BNC. Pomimo uzyskania prawidłowego działania układu sygnał $\overline{WAIT}$ był zbyt słaby, aby procesor mógł zauważyć jego zmiany- przez cały czas traktował jego stan jako niski. Aby uniknąć tej sytuacji podczas testowania układu korzystaliśmy z sond dołączonych do oscyloskopu.
Kolejnym problemem było podłączenie licznika do układu z zadania drugiego. Podczas testów okazało się, że sygnał przeniesienia znikał zbyt szybko, więc procesor nie zauważał zmiany sygnału $\overline{WAIT}$ i nie mógł zmienić stanu wyjść, wobec tego licznik zaczynał liczyć od zera. Powodowało to zatrzymanie procesora. Problem następował przy zliczaniu do 16. Znaleźliśmy dwa rozwiązania tego problemu, jednym było zliczanie do 8 i wykorzystanie najstarszego bitu jako bit przeniesienia lub użycie rejestru. Ostatecznie zdecydowaliśmy się na wykorzystanie drugiej opcji.


\end{document}
